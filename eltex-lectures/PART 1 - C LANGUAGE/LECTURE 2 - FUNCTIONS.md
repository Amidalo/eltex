Функции нужны, чтобы не дублировать блоки кода.

Однако стоит понимать, что когда мы пишем программы, то с позиции машинного языка в функции может быть несколько машинных инструкций (какое-то малое количество), но когда мы вызываем эту же функцию, вызов функции с позиции процессора может занимать большое количество машинных инструкций. То есть чтобы не дублировать, к примеру, 5 инструкций, сделали, допустим, 305 инструкций. Следовательно, не надо доходить до написания функций в одну-две строчки, это не очень хорошо.

Но если это сделать все-таки нужно (написать маленькую функцию), следует написать `inline` перед типом возвращаемого значения: это заставит компилятор в момент компиляции не вставлять вызов функции, когда машинный код генерируется, а вставить тело функции вместо вызова функции -> код дублируется, но быстрее выполняется.

#### Как возвращать более сложные типы, для которых не предусмотрена операция присвоения?
Речь идет о структурах, массивах, строках.

Если отвечать на вопрос, то для этого в языке используются указатели. Для этого просто передают адрес в функцию, а уже в функции меняют сам объект.
```c
int add(int param1, int param2, int* param3)
{
	*param3 = param1 + param2;
	param1++;
	return 0;
}
...
int sum = 0; // 11
int a = 5; // так и останется 5, не смотря на param1++ (т.к. не указатель)
...
add(a, 6, &sum);
```

Когда мы передаем параметры в функцию, мы не передаем сам объект, мы копируем его в параметры функции. То есть, если бы мы передали не адрес `&sum`, а просто `sum`, то в `param3` просто бы скопировалось значение `sum` (число 0). При этом у нас бы ничего не поменялось.

Другими словами, параметры просто копируются, мы не можем в функцию передать сам объект (можем только через указатель), при передачи как значения внутри области памяти функции создаются для параметров ячейки, куда копируются значения (функция работает с копиями, а когда он завершит свою работу, эти копии просто перестанут существовать, сами исходники будут неизменённые).

#### Функции с переменным количеством параметров
Форма объявления следующая:
```c
// type = char, int, float, short ...
int my_func(type *format, ...)
{
	...
}
```
Первым параметром объявить какой-либо стандартный тип, затем после запятой поставить троеточие -> дальше идут сколько угодно любого типа параметров. Как их обрабатывать? -> `#include <stdarg.h>` позволяет создать подобие структуры списка аргументов. Через первый параметр мы получаем доступ к следующему параметру (мы знаем, что первым параметром идет указатель, который всегда занимает 4 байта в 32 разрядной системе -> прыгаем на 4 байта в памяти вперед, чтобы увидеть следующий параметр). Чтобы этот параметр забрать, нужно знать его тип, через макрос `va_arg(args, int);`, где мы указываем начало следующего параметра и его тип (не всегда int, а как тогда догадаться?). Для этого нам и нужен первый параметр, ведь в нем кодируют какое количество дальше будет параметров и какого типа они будут (так работает функция `printf`, где мы ставим служебные символы `%d`  и тому подобное. Этим мы говорим какие типы будут у параметров и сколько их будет).
```c
#include <stdarg.h>
...
int my_func(char *format, ...)
{
	va_list args;
	
	va_start(args, format);
	...
	va_arg(args, int);
	...
	va_end(args);
	return 0;
}
```
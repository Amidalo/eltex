Производный тип - это когда мы можем объединять стандартные типы в группы для формирования более сложного типа. Для этого нужны структуры. Структуры объединяют другие типы, чтобы они выглядели как единый объект с одной областью памяти.

```c
// Ниже пример того, как описывается структура синтаксически
// Описание структуры выносится в заголовочный файл .h по причине того, что это просто определение нового типа (память при определении нового типа не выделяется). Мы просто даем компилятору понять, что у нас появился новый тип данных
struct test
{
	char a;
	int b;
};

// Объявление экземпляра my_test нового типа test
struct test my_test;

// Получение доступа к полям
my_test.a = 'A';
my_test.b = 12345;
```
---
#### Как выделяется память под созданный объект? Чему будет равен `sizeof(struct test)?
В языке C когда бы объявляем какой-либо объект, это означает, что где-то в памяти нам выделилась ячейка (откуда будет начинаться данный тип). Сколько в памяти этот объект занимает, столько в памяти будет непрерывно идти участок, который будет принадлежать данному объекту.

sizeof(struct test) = 8 байт, а память будет выглядеть как на картинке ниже (если пройтись по байтно char* prt = &my_test):
![[Pasted image 20260205235847.png]]
Тут сразу возникает вопрос откуда взялись нули и почему оператор sizeof выдает нам 8, а не 5? Проблема заключается в процессорах, в их архитектурных особенностях: мы можем считывать из памяти 1 байт, 2, 4, 8, 16 - степени двойки. А еще к этому переменные должны располагаться по адресу кратному этой же степени.

char - 1 байт -> может располагаться в памяти где-угодно.
short - 2 байт -> может располагаться по адресу кратному 2.
int - 4 байт -> по адресу кратному 4.
И так далее... 
Если данные находятся по своему кратному адресу, то процессор будет считывать их в одну инструкцию.

Процессор может считывать данные только по кратным адресам. По картинке ниже видно, что мы хотим прочитать int - 4 байт -> 4 байтные адреса считываются только по адресам кратным 4.
![[Pasted image 20260206150743.png]]
Процессор прочитает первые 4 байта от адреса 42 -> 38, 39, 40, 41. Ближайший адрес, который кратен 4, является 40. Процессор возьмет эти 4 байта (40, 41, 42, 43) и прочитает: нужные нам 2 байта (57, 48) находятся в младшей части, а должны они быть в старшей. Затем он прочитает еще одно слово (44, 45, 46, 47): нужные нам 2 байта (желтые нули) находятся в старшей части, а должны быть в младшей. Процессор просто сдвинет эти байты, сложит эти два числа и получит наше число -> процессору понадобилось 5 инструкций, чтобы прочитать число типа int, адрес которого не был кратен 4. Вот и ответ на вопрос откуда взялись нули и почему оператор sizeof выдает нам 8, а не 5: чтобы расположить ту или иную переменную по кратному адресу и прочитать ее за одну инструкцию.

Ниже пример того, как не надо и надо создавать структуру.
![[Pasted image 20260206154722.png]]

x86 архитектура может работать как с выровненными данными, так и с не выровненными данными. Есть такие архитектуры, которые работают только с выравненными: если переменную расположить не по кратному адресу, будет непредсказуемое поведение процессора. 
Конечно, компилятор за нас располагает переменные, но нам никто не мешает объявить указатель и в этот указатель, например int, написать не кратный 4 адрес. А в случае разыменования произойдет критическая ошибка.

---
#### Как выключить выравнивание в языке C?
Выключить выравнивание можно, однако работа с данными будет происходить медленнее. Чтобы это сделать, нужно добавить следующую конструкцию:
```c
// __attribute__((packed)) говорит компилятору о том, что структура уже упакована  и не надо ее добивать нулями, тогда sizeof(struct test) будет равен 5 байт.

struct test
{
	char a;
	int b;
}__attribute__((packed));
```

#### Дополнение по синтаксису
```c
// Этот синтаксик заключается в том, что мы определяем безымянную структуру и создаем экземпляр этой структуры под именем test. Если потребуется создать еще один экземпляр, то сделать это не получится, так как имени у этой структуры нет
struct
{
	char a;
	int b;
} test;

struct test1
{
	char a;
	int b;
};

int main(void)
{
	struct test1 st;
	struct test1 *ptr;
	
	ptr = &st;
	(*ptr).a = 'A'; // Пример обращения к полю через разыменование указателя
	ptr->a = 'A'; // Пример обращения с помощью ->
	
	//------------------//
	
	struct test1 s[10];
	s[0].a = 'A'; // Получение доступа к конкретному полю конкретного элемента массива
	s[1].b = 12345;
	
}
```

Нельзя присваивать структуре структуру, по крайней мере в 89 стандарте. В 99 стандарте это сделать можно.

Внутри структур можно определять битовые поля.
```c
// структура test занимает ровно 1 байт
struct test
{
	unsigned char b1:1; // имя:сколько это поле будет занимать бит
	unsigned char b2:1;
	unsigned char b3:1;
	unsigned char b4:1;
	unsigned char b5:1;
	unsigned char b6:1;
	unsigned char b7:1;
	unsigned char b8:1;
};

int main(void)
{
	char a = 0b11011001;
	struct test* ptr;
	
	ptr = (struct test*) &a;
	ptr->b5 = 0;
}
```

#### Объединения (union)
В объединении все поля начинаются с одного и того же адреса.
```c
union test
{
	char a;
	int b;
};

int main(void)
{
	union test my_test;
	// Смотреть на скриншот 4.1
	my_test.a = 'A';
	
	// Смотреть на скриншот 4.2
	my_test.b = 12345;
	
}
```
На скриншоте ниже видно, что мы просто проинициализировали поле a экземпляра my_test.
![[Pasted image 20260207200141.png]] 
Скриншот 4.1

Если же обратиться к полю b, то мы обращаемся сразу ко всем 4 байтам. Если мы меняем какое-то из полей, то наше изменение влияет и на другие поля.
![[Pasted image 20260207200615.png]]
Скриншот 4.2

Объединения нужны для того, чтобы мы могли создавать универсальную функцию, которая бы могла принимать разные типы данных. Это как перегрузка функций в других языках, которая не поддерживается в языке программирования C.

Принцип работы: вы создаете union, перечисляете в нем все интересующие вас типы. Сам union будет размером в максимальный тип. Если максимальный тип int = 4 байта, то выравниваться он будет по адресу кратному 4

```c
int add(union test param1, int type)
{
	if (type == 1)
	{
		param1.a = 'C';
	}
	else if (type == 2)
	{
		param1.b += 15; 
	}
}

int main(void)
{
	...
	add(param1, 1);
}
```

#### Перечисления (enum)
```c
// 0 = RED
// 1 = ORANGE
// 2 = YELLOW
// 3 = GREEN
// 16 = BLUE
// 17 = PINK
// 164 = BLACK
// 165 = BRAUN
enum colors {RED, ORANGE, YELLOW, GREEN, BLUE = 16, PINK, BLACK = 164, BRAUN};

int main(void)
{
	enum colors cl;
	cl = RED;
}
```
В перечислениях мы пишем литеральные названия, аналог макро определения. Каждому такому литералу соответствует константа - число.


#### Typedef
typedef нужен для создания alias'ов (псевдонимов, сокращений). 
```c
typedef unsigned int uint;
uint a;

typedef struct test test;
test a;
```